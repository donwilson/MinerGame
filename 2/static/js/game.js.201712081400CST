	
	// https://phaser.io/examples
	// https://phaser.io/tutorials/making-your-first-phaser-game
	
	var game = new Phaser.Game(800, 600, Phaser.AUTO, "", {
		'preload': preload,
		'create': create,
		'update': update,
		'render': render
	});
	
	
	// preload
	
	function preload() {
		game.load.image('tiles', "/static/images/world.png");
		game.load.spritesheet('players', "/static/images/players.png", 16, 16);
	}
	
	
	// create
	var custWorld;
	var map;
	var layer;
	
	var player;
	var playerCharacter;
	
	var marker;
	var currentDataString;
	var cursors;
	var wasd;
	
	var playable_characters = {
		'man': {
			'spritesheet': "players",
			'default_frame': 0,
			'animations': {
				'stand_left': [9],
				'run_left': [10, 11],
				'stand_right': [18],
				'run_right': [19, 20]
			}
		},
		'woman': {
			'spritesheet': "players",
			'default_frame': 3,
			'animations': {
				'stand_left': [12],
				'run_left': [13, 14],
				'stand_right': [21],
				'run_right': [22, 23]
			}
		},
		'alien': {
			'spritesheet': "players",
			'default_frame': 6,
			'animations': {
				'stand_left': [15],
				'run_left': [16, 17],
				'stand_right': [24],
				'run_right': [25, 26]
			}
		}
	};
	var playable_character_keys = ["man", "woman", "alien"];
	
	function create() {
		// arcade physics
		game.physics.startSystem(Phaser.Physics.P2JS);
		
		// controls
		cursors = game.input.keyboard.createCursorKeys();
		wasd = {
			'up': game.input.keyboard.addKey(Phaser.Keyboard.W),
			'left': game.input.keyboard.addKey(Phaser.Keyboard.A),
			'down': game.input.keyboard.addKey(Phaser.Keyboard.S),
			'right': game.input.keyboard.addKey(Phaser.Keyboard.D),
		};
		
		// make world
		custWorld = new customGameWorld(game.rnd.between(150, 200), game.rnd.between(300, 350), 5);
		
		// add world data to game cache
		//game.cache.addTilemap('dynamicMap', null, custWorld.toCSV(), Phaser.Tilemap.CSV);
		game.cache.addTilemap('dynamicMap', null, custWorld.toJSON(), Phaser.Tilemap.TILED_JSON);
		
		// tilemap
		map = game.add.tilemap('dynamicMap', 16, 16);
		
		// 'tiles' = cache image key
		map.addTilesetImage('tiles', 'tiles', 16, 16);
		
		// layer 0
		//layer = map.createLayer(0);
		layer = map.createLayer("Tile Layer 1");
		
		// resize world to match layer tilemap size
		layer.resizeWorld();
		
		// add collision to layer tiles (done before generating p2 bodies)
		map.setCollision(custWorld.getTileSpritesCollideableWithPlayer(), true, layer);
		
		// enable physics on tiles
		game.physics.p2.convertTilemap(map, layer);
		
		// make cursor marker
		marker = game.add.graphics();
		marker.lineStyle(2, 0xffffff, 1);
		marker.drawRect(0, 0, 16, 16);
		
		// player
		var playerSpawn = custWorld.getSpawn();
		playerCharacter = playable_characters[ game.rnd.pick( playable_character_keys ) ];
		//player = game.add.sprite(((playerSpawn.x * 16) + (16 / 2)), ((playerSpawn.y * 16) + (16 / 2)), 'players', playerCharacter.default_frame);
		player = game.add.sprite((playerSpawn.x * 16), (playerSpawn.y * 16), 'players', playerCharacter.default_frame);
		
		for(var key in playerCharacter.animations) {
			if(playerCharacter.animations.hasOwnProperty(key)) {
				player.animations.add(key, playerCharacter.animations[ key ], 10, true);
			}
		}
		
		game.physics.p2.enable(player);
		player.body.fixedRotation = true;
		
		// make camera follow player
		game.camera.follow(player);
		
		// reset physics bounds to resized world (from layer.resizeWorld)
		game.physics.p2.setBoundsToWorld(true, true, true, true, false);
		
		// enable gravity
		game.physics.p2.gravity.y = 250;
		game.physics.p2.restitution = 0;
		
		
		
		
		// input callbacks
		game.input.addMoveCallback(updateMarker, this);
		game.input.onDown.add(getTileProperties, this);
		
		
		
		
	}
	
	
	// update
	
	function update() {
		marker.x = (layer.getTileX(game.input.activePointer.worldX) * 16);
		marker.y = (layer.getTileY(game.input.activePointer.worldY) * 16);
		
		var desired_player_speed_per_second = 32;
		var player_speed = (desired_player_speed_per_second * game.time.physicsElapsed);
		var player_jump_amount = 100;
		
		var running_left = cursors.left.isDown || wasd.left.isDown || false;
		var running_right = cursors.right.isDown || wasd.right.isDown || false;
		var jumping = cursors.up.isDown || wasd.up.isDown || false;
		
		if(jumping) {
			player.body.velocity.y = -player_jump_amount;
		}
		
		if(running_left && !running_right) {
			player.body.x -= player_speed;
			
			if(jumping) {
				player.animations.play('stand_left');
			} else {
				player.animations.play('run_left');
			}
		} else if(running_right && !running_left) {
			player.body.x += player_speed;
			
			if(jumping) {
				player.animations.play('stand_right');
			} else {
				player.animations.play('run_right');
			}
		} else {
			// standing still
			player.animations.stop();
			player.frame = playerCharacter.default_frame;
		}
		
		
	}
	
	
	// render
	
	function render() {
		//game.debug.cameraInfo(game.camera, 16, 38);
		
		if(currentDataString) {
			game.debug.text(currentDataString, 16, 16);
		} else {
			game.debug.text("Click on a tile to reveal the properties of the tile", 16, 16);
		}
	}
	
	
	
	
	// UTILITIES
	////////////
	
	function updateMarker() {
		marker.x = (layer.getTileX(game.input.activePointer.worldX) * 16);
		marker.y = (layer.getTileY(game.input.activePointer.worldY) * 16);
	}
	
	// tile properties
	function getTileProperties() {
		var x = layer.getTileX(game.input.activePointer.worldX);
		var y = layer.getTileY(game.input.activePointer.worldY);
		
		if((x < 0) || (x > custWorld.width) || (y < 0) || (y > custWorld.height)) {
			currentDataString = "";
			
			return;
		}
		
		var phaser_tile = map.getTile(x, y, layer);
		var tile = custWorld.getTile(x, y);
		
		
		// Note: JSON.stringify will convert the object tile properties to a string
		currentDataString = x +"x"+ y +" ("+ tile.type +"): "+ JSON.stringify( tile.properties );
		
		// set property value on the fly:
		//tile.properties.wibble = true;
	}
	
	var tile_types = {
		'air': {
			'sprites': [90],
			'collide': false,
			'properties': {
				'title': "Air",
				'strength': 0
			}
		},
		'dirt': {
			'sprites': [3, 5, 6],
			'collide': true,
			'properties': {
				'title': "Dirt",
				'strength': 1
			}
		},
		'stone': {
			'sprites': [27, 28, 29, 30],
			'collide': true,
			'properties': {
				'title': "Stone",
				'strength': 3
			}
		},
		'wood': {
			'sprites': [36, 37, 38, 39, 40],
			'collide': true,
			'properties': {
				'title': "Wood",
				'strength': 3
			}
		},
		'ore': {
			'sprites': [16, 17, 18, 19, 20],
			'collide': true,
			'properties': {
				'title': "Ore",
				'strength': 5
			}
		},
		'lava': {
			'sprites': [76],
			'collide': true,
			'properties': {
				'title': "Lava",
				'strength': 0
			}
		}
	};
	
	// tile object
	function customTile(map_x, map_y, type, properties) {
		this.type = type;
		this.x = map_x;
		this.y = map_y;
		this.sprite = Phaser.ArrayUtils.getRandomItem( tile_types[ this.type ].sprites );
		this.properties = tile_types[ this.type ].properties;
		this.collides = tile_types[ this.type ].collide || false;
		
		this.getTileSprite = function() {
			return this.sprite;
		};
		
		this.collidesWithPlayer = function() {
			return this.collides;
		};
	}
	
	// game world object
	function customGameWorld(num_tiles_x, num_tiles_y, max_sky) {
		this.tiles = [];
		this.width = num_tiles_x || 100;
		this.height = num_tiles_y || 250;
		this.height_sky = max_sky || 30;
		
		// function to place tile
		this.place_tile = function(x, y, tile_type) {
			if((x < 0) || (x >= this.width) || (y < 0) || (y >= this.height) || !tile_types.hasOwnProperty(tile_type)) {
				return false;
			}
			
			this.tiles[ y ][ x ] = new customTile(x, y, tile_type);
		};
		
		// start world creation by filling entire world with air
		this.generate_addAir = function() {
			var y, x;
			
			for(y = 0; y < this.height; y++) {
				this.tiles[ y ] = [];
				
				for(x = 0; x < this.width; x++) {
					this.place_tile(x, y, 'air');
				}
			}
		};
		
		// add dirt to world
		this.generate_addDirt = function() {
			var y, x;
			
			for(y = this.height_sky; y < this.height; y++) {
				for(x = 0; x < this.width; x++) {
					this.place_tile(x, y, 'dirt');
				}
			}
		};
		
		// add stone to world
		this.generate_addStone = function() {
			
			var y_min = (this.height_sky + 5);
			//var num_groups = game.rnd.between(6, 10);   // number of stone groups to make
			var num_groups = Math.round(Math.sqrt( (this.width * this.height) ));   // number of stone groups to make
			var i;
			var center_x, center_y;
			
			for(i = 0; i < num_groups; i++) {
				center_x = game.rnd.between(0, this.width);
				center_y = game.rnd.between(y_min, this.height);
				
				
				this.place_tile(center_x, (center_y - 1), 'stone');
				this.place_tile((center_x - 1), center_y, 'stone');
				this.place_tile(center_x, center_y, 'stone');
				this.place_tile((center_x + 1), center_y, 'stone');
				this.place_tile(center_x, (center_y + 1), 'stone');
			}
		};
		
		// add wood to world
		this.generate_addWood = function() {
			
		};
		
		// add ore to world
		this.generate_addOre = function() {
			
		};
		
		// add lava to world
		this.generate_addLava = function() {
			var x, y;
			var lava_height = 3;
			
			for(y = (this.height - 1); y > ((this.height - 1) - lava_height); y--) {
				for(x = 0; x < this.width; x++) {
					this.place_tile(x, y, 'lava');
				}
			}
		};
		
		
		
		// return {x: X, y: Y} of spawn point
		this.getSpawn = function() {
			var points = [];
			var x, y;
			var tile, tile_below;
			
			// scan left to right, top to bottom, find bottom most air from top
			for(x = 0; x < this.width; x++) {
				for(y = 0; y < this.height; y++) {
					tile = this.getTile(x, y);
					
					if("air" === tile.type) {
						tile_below = this.getTile(x, (y + 1));
						
						if((false !== tile_below) && tile_below.collidesWithPlayer()) {
							points.push({'x': x, 'y': y});
							
							break;
						}
					}
				}
			}
			
			if(!points.length) {
				// unable to organically find a spawn, choose one at random that "should" have something open
				return {
					'x': game.rnd.between(0, (this.width - 1)),
					'y': (this.height_sky - 1)
				};
			}
			
			return game.rnd.pick(points);
		};
		
		// build index of tile sprites that collide with player
		this.getTileSpritesCollideableWithPlayer = function() {
			var sprites = [];
			var key;
			
			for(key in tile_types) {
				if(tile_types.hasOwnProperty(key)) {
					if(tile_types[ key ].collide && tile_types[ key ].sprites.length) {
						//console.log("gTSCWP("+ key +") collides: "+ tile_types[ key ].sprites);
						
						sprites = sprites.concat( tile_types[ key ].sprites );
					}
				}
			}
			
			console.log("gTSCWP collisions: "+ sprites.join(","));
			
			return sprites;
		};
		
		
		// return customTile at x,y
		this.getTile = function(x, y) {
			if(!this.tiles[ y ].length || !this.tiles[ y ][ x ]) {
				return false;
			}
			
			return this.tiles[ y ][ x ];
		};
		
		// generate CSV of map
		this.toCSV = function() {
			var y_data = [],
				x_data;
			
			for(var y = 0; y < this.height; y++) {
				x_data = [];
				
				for(var x = 0; x < this.width; x++) {
					x_data.push(this.tiles[ y ][ x ].getTileSprite());
				}
				
				y_data.push( x_data.join(",") );
			}
			
			return y_data.join("\n");
		};
		
		// generate Tiled JSON of map
		this.toJSON = function() {
			var raw_layer_tiles = [];
			var tile_properties = {};
			
			// convert tile multi array to single array
			for(var y = 0; y < this.height; y++) {
				var tmp = [];
				
				for(var x = 0; x < this.width; x++) {
					var tile = this.tiles[ y ][ x ];
					
					var sprite_number = tile.getTileSprite();
					tmp.push(sprite_number +"("+ tile.properties.type +")");
					
					raw_layer_tiles.push(sprite_number);
					
					// doesn't work: (maybe tileproperties is limited to properties of tile type, not exact tile)
					//tile_properties[ ((this.width * (y - 1)) + x).toString() ] = tile.properties;
				}
			}
			
			// http://docs.mapeditor.org/fr/latest/reference/json-map-format/
			var data = {
				"height": 6,
				"layers": [
					{
						"data": raw_layer_tiles,
						"height": this.height,
						"name": "Tile Layer 1",
						"opacity": 1,
						"type": "tilelayer",
						"visible": true,
						"width": this.width,
						"x": 0,
						"y": 0
					}
				],
				"nextobjectid": 6,
				"orientation": "orthogonal",
				"properties": {
					
				},
				"renderorder": "right-down",
				"tileheight": 16,
				"tilesets": [
					{
						"firstgid": 1,
						"image": "/static/images/world.png",
						"imageheight": 240,
						"imagewidth": 96,
						"margin": 0,
						"name": "tiles",
						"properties": {
							
						},
						"spacing": 0,
						"tileheight": 16,
						"tileproperties": tile_properties,
						"tilewidth": 16
					}
				],
				"tilewidth": 16,
				"version": 1,
				"width": 15
			};
			
			//return JSON.stringify(data);
			return data;
		}
		
		
		// create world
		this.generate_addAir();
		this.generate_addDirt();
		this.generate_addStone();
		this.generate_addWood();
		this.generate_addOre();
		this.generate_addLava();
	}